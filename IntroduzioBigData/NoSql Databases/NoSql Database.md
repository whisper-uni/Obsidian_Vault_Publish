### Key-value, Documentali, Colonnari, Grafo
Alla fine degli anni 90’ e nei primi anni 2000, quando sono iniziate a nascere le applicazioni web caratte rizzate da una impredicibilità dei dati da gestire (in termini di volume e varietà) e del numero degli utenti, i progettisti hanno iniziato a riscontrare diverse tipologie di problemi legati ai tradizionali Relational Database Management System (RDBMS), in termini di Scalabilità, Costi, Flessibilità e Disponibilità. 
Tutto questo ha fatto si che si pensassero nuove architetture basate su sistemi distribuiti, e caratterizzate dalla capacità di gestire grandi volumi di dati secondo concetti più semplici che indirizzano questi problemi. Esistono diverse tipologie di database NoSQL, tra cui: 
- [[Key-Value]] (Redis, DynamoDB): database che gestiscono oggetti formati da coppie di chiave (identificativo del record) e valore (possono esserci anche più valori), che possono anche essere di diverso tipo; 
- Documentali (MongoDB, CouchDB): estensione dei Key-Value, associano ad una chiave un documento, quindi un testo in formato JSON o XML che può essere ricorsivo, quindi può contenere tipologie di dati molto variegati; 
- Colonnari(Cassandra, HBase): database che lavorano su base colonna, dove un record (unità informativa) può essere costituito da colonne diverse da quelle degli altri record (non vi è un numero fisso di colonne e un numero variabile di record; vi è un numero variabile di righe e di colonne), aumentando la flessibilità del sistema stesso; 
- A grafo (Neo4j): i dati sono gestiti tramite nodi (i dati stessi) e archi (relazioni tra i dati). Tali database sono fatti per gestire e andare ad interrogare relazioni e percorsi possibili tra i nodi, specie in problemi di analisi predittiva, in cui si vogliono scoprire potenziali relazioni di causa-effetto tra nodi.

### Obiettivi: Persistenza, consistenza, disponibilità
Gli obiettivi di un qualsiasi sistema di gestione dei dati sono: 
	• garantire la **persistenza** dei dati: nel caso di failure del sistema di gestione del database, i dati in esso contenuti devono essere comunque disponibili non appena ripristinata la situazione corretta, quindi non devono andar persi; 
	• mantenere la **consistenza** dei dati: a fronte di una operazione di scrittura o di aggiornamento del contenuto, i dati possono essere letti in modo consistente rispetto alle operazioni effettuate; 
	• assicurare la **disponibilità** dei dati: a fronte di guasti di uno degli item dell’infrastruttura, è necessario mantenere la disponibilità di accesso in lettura o scrittura ai dati stessi.
	
Nel caso di sistemi distribuiti la consistenza e la disponibilità generano delle situazioni di difficoltà, specie per le performance. In termini di gestione della consistenza, quando effettuano delle operazioni di scrittura, il fatto di generare repliche può non essere un problema, a che si verifichi un guasto sul primo server prima che vada completata l’operazione di scrittura prima replica; in questo caso si avrebbe una potenziale inconsistenza dei dati. Nel caso di operazioni di lettura invece è difficile capire se si è in una situazione di inconsistenza del dato, non avendo modo di osservare se magari nel frattempo sono state effettuate richieste di scrittura e/o aggiornamento. Dunque il concetto che ne nasce è quello di **Eventual Consistency**.
### Eventual consistency
ovvero la possibilità per un database di consentire operazioni di modifica, e di ottenere la consistenza generale del sistema solo dopo il verificarsi di un certo evento, al termine di tutte le operazioni. Ne deriva un ulteriore concetto, quello di **Quorum**, ossia il numero di server che devono rispondere ad operazioni di lettura e/o scrittura affinché esse siano considerate complete. Potrebbe quindi essere necessario definire il Quorum in maniera corretta, come: Il corretto bilanciamento tra le necessità di Consistenza rispetto ai Tempi di Risposta e rispetto alla Durabilità, ossia la proprietà di mantenere la versione corretta dei dati per un lungo periodo di tempo. ==Questo significa che la Consistenza e il Tempo di Risposta sono direttamente correlate==. 

> [!example]- Esempio Quorum
> Nel caso di Quorum pari a 3 si avrebbe il tempo di risposta necessario ad effettuare l’aggiornamento su 3 server; se il Quorum fosse 1, il tempo di risposta sarebbe minore, ma non si avrebbe sufficiente e necessaria Consistenza, oltre ad una scarsa Durabilità nel caso in cui il server fallisse. 



Altro concetto fondamentale per i database distribuiti è il cosiddetto **Teorema CAP**, noto anche come Teorema di Brewer. Questo afferma che i database distribuiti non possono fornire al tempo stesso Consistency, Availability (intesa come la capacità di rispondere a una qualsiasi query in un tempo ristretto) e Partition Protection(intesa come la capacità dei server del database di continuare ad essere disponibili e a fornire i dati anche in seguito ad un fallimento di una partizione della rete, ripristinando la situazione precedente). Quindi bisogna lavorare per far si che i database distribuiti abbiano il giusto bilanciamento tra queste tre caratteristiche. Ancora a differenza dei tradizionali database relazionali, che godono delle proprietà Atomicity, Consistency, Isolation, Durability (ACID), i database NoSQL godono delle proprietà Basically Available, Soft state, Eventually Consistent (BASE): disponibilità di tipo basico (non totale), non garantiscono che i dati siano sempre in uno stato univoco fin quando l’operazione non si è propagata su tutto il database distribuito da considerarsi consistente, e sono Eventual Consistency. Esistono diverse tipologie di Eventual Consistency: • Causal Consistency, deve essere mantenuto il rapporto di causa-effetto tra le operazioni quando si effettuano una sequenza di operazioni; • Read-Your-Write Consistency, quando un utente effettua una scrittura, poi un’operazione di lettura, que- sta ritorna esattamente quello che era stato lanciato in scrittura poco prima, garantendo la consistenza dell’operazione di scrittura/lettura; • Session Consistency, all’interno della sessione utente le operazioni effettuate (lettura, scrittura, modifica) sono consistenti tra loro e seguono il filone applicativo che le distingue; • Monotonic Read Consistency, se vi è una sequenza di operazioni di lettura fermo restando il contenuto del database, ottengo sempre il medesimo set di risultati; • Monotonic Write Consistency, se vi è una sequenza di operazioni di scrittura e/o aggiornamento, ottengo a fronte della medesima sequenza di operazioni, il medesimo risultato finale.